#!/bin/bash

base_dir="$HOME"/cld

db_port="15432"
infra_services=("garage" "keydb" "haproxy" "caddy" "patroni")
ignore=("_archive" ".github" ".git")

declare -rA pattern=(
	[jfs]="/mnt/jfs"
	[nas]="/mnt/nas"
	[crypt]="/mnt/crypt"
)

dry_run=0
detach=0

print_usage() {
	prg=$(basename "$0")

	echo "Usage: $prg [OPTIONS] TARGET ACTION"
	echo
	echo "Options:"
	echo "  -n, --dry-run       Perform a dry run without making changes"
	echo "  -d, --detach        Run jobs with -detach flag"
	echo
	echo "Targets:"
	echo "  infra               Target infrastructure jobs"
	echo "  services            Target application jobs"
	echo "  all                 Target both infrastucture and application jobs"
	echo "  db                  Target jobs that use Postgres cluster"
	echo "  nas                 Target jobs that use NAS"
	echo "  crypt               Target jobs that use crypt remote"
	echo "  jfs                 Target jobs that use JuiceFS"
	echo "  reconcile           Reconcile container image for application jobs"
	echo
	echo "Actions:"
	echo "  up                  Bring the specified target(s) up"
	echo "  down                Bring the specified target(s) down"
	echo "  all                 Reconcile container images for all application jobs"
	echo "  <job>               Reconcile container images for specific application job"
	echo
	echo "Examples:"
	echo "  $prg -n services up"
	echo "  $prg reconcile all"
	echo "  $prg reconcile immich"

	exit 1
}

is_running() {
	nomad status "$1" 2> /dev/null | grep -q "running"
}

is_in_array() {
	local item="$1"
	shift
	local array=("$@") # dirty hack: collect all remaining arguments to form the array

	for element in "${array[@]}"; do
		if [[ "$item" == "$element" ]]; then
			return 0
		fi
	done

	return 1
}

get_job_name() {
	local jobfile="$1"
	grep -Po '^job\s*"\K[^"]+' "$jobfile"
}

run_job() {
	local job_file="$1"
	local job_name="$2"

	if is_running "$job_name"; then
		return
	fi

	if ((dry_run)); then
		echo "DRY-RUN: $job_name"
		return
	fi

	echo "Running job \"$job_name\" ($job_file)"
	if ((detach)); then
		nomad run -detach "$job_file"
	else
		nomad run "$job_file"
	fi
}

stop_job() {
	local job="$1"

	if ! is_running "$job"; then
		return
	fi

	if ((dry_run)); then
		echo "DRY-RUN: $job"
		return
	fi

	echo "Stopping job \"$job_name\""
	nomad stop -purge "$job"
}

reconcile_job() {
	local job="$1"
	local current_image
	local desired_image

	if is_in_array "$job" "${ignore[@]}"; then
		return
	fi

	if ! is_running "$job"; then
		echo "Job \"$job\" is not running"
		return
	fi

	current_image=$(
		nomad job inspect -hcl "$job" |
			grep -Pzo 'image\s*=\s*(".*?"|\{[^}]*\})' |
			tr '\0' '\n' |
			grep -v "local.image"
	)

	desired_image=$(
		grep -Pzo 'image\s*=\s*(".*?"|\{[^}]*\})' "$job/${job}.hcl" |
			tr '\0' '\n' |
			grep -v "local.image"
	)

	if [[ "$current_image" == "$desired_image" ]]; then
		return
	fi

	if is_in_array "$job" "${infra_services[@]}"; then
		echo "Skipping infra job \"$job\""
		return
	fi

	pushd "$base_dir/$job" > /dev/null || return

	for job_file in *.hcl; do
		run_job "$job_file"
	done

	popd > /dev/null || return
}

down_by_jobspec() {
	local this_pattern="$1"
	local job_name

	find "$base_dir" -maxdepth 2 -iname "*.hcl" -type f | while read -r f; do
		if ! grep -q "$this_pattern" "$f"; then
			continue
		fi

		job_name="$(get_job_name "$f")"
		if [[ -n "$job_name" ]]; then
			stop_job "$job_name"
		fi
	done
}

nas() {
	local action="$1"

	case "$action" in
		up)
			echo "not implemented"
			;;
		down)
			down_by_jobspec "${pattern[nas]}"
			;;
	esac
}

jfs() {
	local action="$1"

	case "$action" in
		up)
			echo "not implemented"
			;;
		down)
			down_by_jobspec "${pattern[jfs]}"
			;;
	esac
}

crypt() {
	local action="$1"

	case "$action" in
		up)
			echo "not implemented"
			;;
		down)
			down_by_jobspec "${pattern[crypt]}"
			;;
	esac
}

db() {
	local action="$1"

	find "$base_dir" -maxdepth 2 ! -path "*/.st*" -type f | while read -r file; do
		if ! grep -q "$db_port" "$file"; then
			continue
		fi

		job_name="$(basename "${file%/*}")"
		case "$action" in
			up)
				echo "not implemented"
				;;
			down)
				if [[ "$job_name" == @(haproxy|patroni) ]]; then
					continue
				fi

				stop_job "$job_name"
				;;
		esac
	done
}

services() {
	local action="$1"

	for dir in "$base_dir"/*; do
		local service
		service="$(basename "$dir")"

		if is_in_array "$service" "${ignore[@]}" || [[ ! -d "$dir" ]]; then
			continue
		fi

		pushd "$dir" > /dev/null || continue
		for job_file in *.hcl; do
			if [[ ! -f "$job_file" ]]; then
				continue
			fi

			local job_name
			job_name="$(get_job_name "$job_file")"

			if [[ -z "$job_name" ]]; then
				continue
			fi

			case "$action" in
				up)
					run_job "$job_file" "$job_name"
					;;
				down)
					if is_in_array "$service" "${infra_services[@]}"; then
						continue
					fi

					stop_job "$job_name"
					;;
			esac
		done

		popd > /dev/null || continue
	done
}

infra() {
	local action="$1"

	for service in "${infra_services[@]}"; do
		pushd "$base_dir/$service" > /dev/null || continue

		for job_file in *.hcl; do
			if [[ ! -f "$job_file" ]]; then
				continue
			fi

			local job_name
			job_name="$(get_job_name "$job_file")"

			if [[ -z "$job_name" ]]; then
				continue
			fi

			case "$action" in
				up)
					run_job "$job_file" "$job_name"
					;;
				down)
					stop_job "$job_name"
					;;
			esac
		done

		popd > /dev/null || continue
	done
}

reconcile() {
	local job="$1"

	case "$job" in
		all)
			for dir in "$base_dir"/*; do
				if [[ ! -d "$dir" ]]; then
					continue
				fi

				service="$(basename "$dir")"
				reconcile_job "$service"
			done
			;;
		*)
			service="$(basename "$base_dir/$job")"
			reconcile_job "$service"
			;;
	esac
}

all() {
	local action="$1"

	case "$action" in
		up)
			infra up
			services up
			;;
		down)
			services down
			infra down
			;;
	esac
}

dispatch() {
	local category="$1"
	local action="$2"

	if [[ -n "$action" && $(declare -f "$category") ]]; then
		"$category" "$action"
	else
		print_usage
	fi
}

for arg in "$@"; do
	case "$arg" in
		-n | --dry-run)
			dry_run=1
			shift
			;;
		-d | --detach)
			detach=1
			shift
			;;
	esac
done

cd "$base_dir" || exit
dispatch "$1" "$2"
